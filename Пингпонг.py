import turtle
import winsound
try:
    # Создаем игровое поле

    sc = turtle.Screen() # присваиваем переменной sc значение модуля turtle класса Turtle()
    sc.title("Игра отбей мяч")  # пишем название игры
    #sc.bgcolor("green")  # задаем цвет игровому полю
    sc.bgpic("photo.gif") # задаем фоновую картинку игровому полюч
    sc.setup(width=800, height=600)  # задаем ширину и высотц игрового поля

    # Левая стенка

    left = turtle.Turtle()  # присваиваем переменной left значение модуля turtle класса Turtle()
    left.speed(0)  # задаем скорость анимации (прорисовки) 0 - максимальная
    left.shape("square")  # задаем форму левой стенки - квадрат(может быть треугольник, круг)
    left.color("black")  # задаем цвет левой стенки - черный
    left.shapesize(stretch_wid=5, stretch_len=1)  # задаем высоту и ширину стенки (1 пункт 20 пикселей)
    left.penup() # поднять ручку чтобы не видеть движения от центра
    left.goto(-350, 0) # устанавливаем начальную позицию левой стенки - центр по х будет на -350
    # (это ширина поля 800 делить на 2 будет -400, 10 пикселей пойдет на половину толщины стенки
    # и оставляем зазор в 40 пикселей между стенкой и краем поля

    # Правая стенка

    right = turtle.Turtle() # присваиваем переменной right значение модуля turtle класса Turtle()
    right.speed(0)  # задаем скорость анимации (прорисовки) 0 - максимальная
    right.shape("square") # задаем форму правой стенки - квадрат(может быть треугольник, круг)
    right.color("black") # задаем цвет левой стенки - черный
    right.shapesize(stretch_wid=5, stretch_len=1) # задаем высоту и ширину стенки (1 пункт 20 пикселей)
    right.penup() # поднять ручку чтобы не видеть движения от центра
    right.goto(350, 0) # устанавливаем начальную позицию правой стенки - центр по х будет на 350
    # (это ширина поля 800 делить на 2 будет 400, 10 пикселей пойдет на половину толщины стенки
    # и оставляем зазор в 40 пикселей между стенкой и краем поля

    # Мяч и установка мяча по центру

    ball = turtle.Turtle() # присваиваем переменной ball значение модуля turtle класса Turtle()
    ball.speed(0)   # задаем скорость анимации (прорисовки) 0 - максимальная
    ball.shape("circle") # задаем форму мяча - круг (может быть треугольник, квадрат)
    ball.color("blue") # задаем цвет мяча - синий
    ball.penup() # поднять ручку чтобы не видеть движения от центра
    ball.goto(0, 0) # координаты начальной позиции мяча
    ball.dx = 4 # скорость перемешения мяча - пикселей за цикл по оси x
    ball.dy = 4 # скорость перемешения мяча - пикселей за цикл по оси y

    # Установка счета в игре на ноль при запуске для счетчика игры

    left_player = 0
    right_player = 0

    # Вывод счета

    bill = turtle.Turtle() # присваиваем переменной bill значение модуля turtle класса Turtle()
    bill.speed(0)  # задаем скорость анимации (прорисовки) 0 - максимальная
    bill.color("blue")  # цвет текста
    bill.penup()  # поднять ручку чтобы не видеть движения от центра
    bill.hideturtle()  # спрятать ручку
    bill.goto(0, 260)  # переход к координате начала текста
    bill.write("Левый : 0    Правый: 0", align="center",
               font=("Courier", 24, "bold"))  # пишем счет игроков вверху


    # Функции отвечаюшие за движения стенок

    def left_up():  # движение левой стенки вверх
        y = left.ycor()  # метод ycor возвращает координату стенки по оси игрек
        y += 20 # добавляем к координате стенки 20 пикселей при каждом цикле и нажатии вверх
        left.sety(y)  # устанавливает новые координаты левой стенки


    def left_down():  # движение левой стенки вниз
        y = left.ycor()  # метод ycor возвращает координату стенки по оси игрек
        y -= 20 # отнимает от координаты стенки 20 пикселей при каждом цикле и нажатии вниз
        left.sety(y)  # устанавливает новые координаты левой стенки


    def right_up():  # движение правой стенки вверх
        y = right.ycor()  # метод ycor возвращает координату стенки по оси игрек
        y += 20 # добавляем к координате стенки 20 пикселей при каждом цикле и нажатии вверх
        right.sety(y)  # устанавливает новые координаты правой стенки


    def right_down():  # движение правой стенки вниз
        y = right.ycor()  # метод ycor возвращает координату стенки по оси игрек
        y -= 20 # отнимает от координаты стенки 20 пикселей при каждом цикле и нажатии вниз
        right.sety(y)  # устанавливает новые координаты правой стенки


    # Связывание с кнопками клавиатуры

    sc.listen()  # слушать ввод с клавиатуры
    sc.onkeypress(left_up, "Insert")  # литера Insert - движение правой стенки вверх
    sc.onkeypress(left_down, "Delete")  # литера Delete - движение правой стенки вниз
    sc.onkeypress(right_up, "Up")  # клавиша вверх - движение правой стенки вверх
    sc.onkeypress(right_down, "Down")  # клавиша вниз - движение правой стенки вниз

    while True:
        sc.update()  # каждый раз при прохождении цикла обновляет экран

        ball.setx(ball.xcor() + ball.dx) # Движение мяча по оси х
        ball.sety(ball.ycor() + ball.dy) # Движение мяча по оси y

    # Проверка не вышли ли стенки за границы экрана
        if left.ycor() > 250: # высота стенки 100 пикселей половина высоты 50 половина высоты экрана 300
            # поэтому ставим 250
            left.sety(250) # если вышла на границу ставим в 250

        elif left.ycor() < -250: # высота стенки 100 пикселей половина высоты 50 половина высоты экрана -300
            # поэтому ставим -250
            left.sety(-250) # если вышла на границу ставим в -250

        elif right.ycor() > 250: # высота стенки 100 пикселей половина высоты 50 половина высоты экрана 300
            # поэтому ставим 250
            right.sety(250) # если вышла на границу ставим в 250

        elif right.ycor() < -250: # высота стенки 100 пикселей половина высоты 50 половина высоты экрана -300
            # поэтому ставим -250
            right.sety(-250)  # если вышла на границу ставим в -250

    # Проверка границ (соударения мяча и основного окна)
        if ball.ycor() > 290: # диаметр мяча 20 пикселей, поэтому проверку делаем край экрана минус половина
            # диаметра мяча
            ball.sety(290) # если вышел за верх то возвращаем на край
            ball.dy *= -1 # после удара меняем направления движения по осям на противоположное

        elif ball.ycor() < -290: # диаметр мяча 20 пикселей, поэтому проверку делаем край экрана минус половина
            # диаметра мяча
            ball.sety(-290) # если вышел возвращаем на край
            ball.dy *= -1 # после удара меняем направления движения по осям на противоположное

        elif ball.xcor() > 390: # диаметр мяча 20 пикселей, поэтому проверку делаем край экрана минус половина
            # диаметра мяча
            ball.goto(0, 0) # если вышел за правый край значит игрок упустил мяч, возвращаем мячь в центр
            ball.dy *= -1 # после выхода меняем направления движения по осям на противоположное
            left_player += 1 # записываем противоположному игроку ондно очко
            bill.clear() # очищаем запись счета чтобы не записалось поверх
            bill.write("Левый : {}    Правый: {}".format(left_player, right_player), align="center",
                       font=("Courier", 24, "bold")) # Выводим  счет на экран

        elif ball.xcor() < -390: # диаметр мяча 20 пикселей, поэтому проверку делаем край экрана минус половина
            # диаметра мяча
            ball.goto(0, 0) # если вышел за правый край значит игрок упустил мяч, возвращаем мячь в центр
            ball.dy *= -1 # после выхода меняем направления движения по осям на противоположное
            right_player += 1 # записываем противоположному игроку ондно очко
            bill.clear() # очищаем запись счета чтобы не записалось поверх
            bill.write("Левый : {}    Правый: {}".format(left_player, right_player), align="center",
                       font=("Courier", 24, "bold")) # Выводим  счет на экран



    # Проверка соударения мяча со стенками
        if ball.xcor() > 330 and (
                ball.ycor() < right.ycor() + 50 and ball.ycor() > right.ycor() - 50): # стенка толшиной 20 пикселей,
            # стоит на координате 350
            # значит край стенки расположен на координате 340 по х Исходя из того что тут все считается от центра мячь
            # должен ударяться о координату 330
            # по длине тоже так, длина стенки 100 пикселей поэтому здесь к центру добавляем по 50 пикселей
            ball.setx(330) # если был удар ставим мяч в позицию 330
            ball.dx *= -1 # придаем мячу обратное ускорение по оси х
            winsound.PlaySound("z.wav", winsound.SND_ASYNC) # запускаем звук удара с флагом асинхронного воспроизведения

        if ball.xcor() < -330 and (
                ball.ycor() < left.ycor() + 50 and ball.ycor() > left.ycor() - 50):
            ball.setx(-330)
            ball.dx *= -1
            winsound.PlaySound("z.wav", winsound.SND_ASYNC)

except Exception as e:
    print('Игра завершена')
# Использовалась обработка всех исключений потому что при закрытии модуля программа выполняется и пытается передать туда
# данные а там не принимают. Поэтому при закрытии окна вылезали ошибки